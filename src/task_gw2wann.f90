!BOP
!
! !ROUTINE: task_gw2wann
!
! !INTERFACE:
      subroutine task_gw2wann 
      
! !DESCRIPTION:
!
! This task calculate the full matrices for Vxc and Sxc in the Kohn-Sham basis, and
! then transfrom them to the Wannier basis. It can be used for the
! subsequent GW+DMFT calculation or the Wannier interpolation of GW band
! structure. 
!
! !USES:
      use bands,       only: nspin,bande,eferks,ibgw,nbgw,eqp,eferqp,&
     &                  efermi 
      use crpa,        only: iop_wf,nlmorb,pln,nbmin_wf,nbmax_wf 
      use constants,   only: HeV,pi
      use freq,        only: nomeg,omega
      use kpoints,     only: nkp,nirkp,get_kvec,kirvecs
      use selfenergy,  only: init_selfenergy,end_selfenergy,iop_sxc, &
     &                  isym_kbz,sigx,sigc,sigm,sxc_wann,vxcmn,vxc_wann,&
     &                  hks_wann,hgw_wann,sxc_wann,vxc_wann,&
     &                  nomeg_mats,sxc_wann_mats,iop_intpl_mats, &
     &                  beta_mats_eV,omega_mats,nomeg_mats,vxcnn,&
     &                  beta_mats
      use xcpot,       only: init_xcpot,end_xcpot
      use modmpi      
      use liboct_parser
      
! !LOCAL VARIABLES:

      implicit none
 
      integer :: iop_mwm   ! control the treatment of mwm  
      integer :: iop_minm  ! control the treatment of mwm  
      integer :: iop_hgw   ! indicating how to define the effective GW Hamiltonian 

      integer :: iq        ! index for q-points
      integer :: iq0       ! index for starting k-points, needed for the restart mode 
      integer :: ierr      ! error code 
      integer :: nktot     ! the total number of k-points considered, and it can be nirkp or nkp depending on isym_kbz

!     variables used for parallelization
      integer :: iq_f,iq_l     !! lower and upper bound for iq
      logical:: lread_eps=.false.
      logical:: ldbg=.false.

      character(len=20):: sname="task_gw2wann"
      character(len=20):: blk_gw2wann="gw2wann"

! !REVISION HISTORY:
!
! Created 19.07.2008 by Hong Jiang
!      
!EOP
!BOC
#ifdef DEBUG
      ldbg = .true.
#endif 

      call boxmsg(6,'*',"Task:GW2WANN") 
!
!     iop_sxc -- determine which approximation to self-energy
!                0 --- GW
!                1 --- exchange-only
!                2 --- static COHSEX
!     iop_wf ---> option about the Wannier function 
!               0 -- use the internally generated WF (not implemented yet!)
!               1 -- use WF generated by dmftproj 
!               2 -- use WF generated by wien2wannier + wannier90 (not implemented yet!)
!     isym_kbz = 0 - calculate Vxc, Sxc in the full BZ
!              = 1 - calculate Vxc, Sxc in the irreducible BZ
!     iop_hgw = 0/1/2 ---> indicating how to define the effective GW Hamiltonian 
!                0 -- no GW Hamiltonian is output
!                1 -- G0W0 
!                2 -- QSGW
!     nomeg_mats --> the number of Matsubara frequencies to which the
!               final self-energies are interpolated
!     
      iop_minm = -1 
      ierr = loct_parse_isdef(blk_gw2wann)
      if(ierr.ne.1) then 
        iop_sxc = 0 
        iop_wf  = 2
        isym_kbz = 1 
        iop_hgw  = 0 
        nomeg_mats = 0 
        iop_intpl_mats = 0 
      else 
        call loct_parse_block_int(blk_gw2wann,0,0,iop_sxc)
        call loct_parse_block_int(blk_gw2wann,0,1,iop_wf)
        call loct_parse_block_int(blk_gw2wann,0,2,isym_kbz)
        call loct_parse_block_int(blk_gw2wann,0,3,iop_hgw)
        if(iop_sxc.eq.0) then 
          call loct_parse_block_int(blk_gw2wann,1,0,nomeg_mats)
          call loct_parse_block_float(blk_gw2wann,1,1,beta_mats_eV) 
          call loct_parse_block_int  (blk_gw2wann,1,2,iop_intpl_mats) 
        endif 
      endif 

      if(iop_sxc.ne.0) then   
         nomeg_mats = 0 
      endif 

      call errmsg(iop_sxc.lt.0.and.iop_sxc.gt.2,sname,&
     &      "unsupported iop_sxc value!! ")

      if(isym_kbz.eq.0) then 
        nktot = nkp
      else 
        nktot = nirkp
      endif 

     !! Read Wannier projectors from case.pln
      if(iop_wf.eq.1) then   !! read WF projectors from dmftproj.x 
        call crpa_readpln
      elseif(iop_wf.eq.2) then !! read WF from a Wannier90 chk file 
        call crpa_readw2w
      else
        write(6,*) "ERROR: not implemented iop_wf=",iop_wf 
      endif

      call init_selfenergy(2) 

      if(myrank.eq.0) then
        call init_xcpot
        call w2k_calcvxcmn(isym_kbz) 
      endif

      call calc_sxcmn(iop_sxc,-1,isym_kbz) 

      if(myrank.eq.0)then
        !! calculate QP energies using the diagonal elements of calculated Sxc matrix 
        call sub_calc_eqp_diag

        !! calculate QP energies using the full Sxc matrix 
        call sub_calc_eqp_full

        !! transform Vxc_{n,n'} and Sxc_{n,n'} to the matrices in the Wannier basis 
        call sub_trans_ks2wann

        !! interpolate the selfenergy to Matsubara frequencies
        if(nomeg_mats.gt.0) then 
          call sub_intpl_mats() 
        endif 

        call write_sxc_wann(isym_kbz,iop_hgw,ierr) 

        if(nomeg_mats.gt.0) deallocate(sxc_wann_mats,omega_mats)
      endif

      call end_selfenergy(2) 
      if(myrank.eq.0) call end_xcpot

      return

      contains 

!---------------------------------------------------------------------!
!    Internal subroutine: Convert all relevant matrices represented   !
!    in terms of KS vectors to those in terms of Wannier functions    !
!---------------------------------------------------------------------!
        subroutine sub_trans_ks2wann()
        implicit none 
        integer:: isp,ik,irk,iw,jw,ie,iom,nbwf,itmp,ik_pln,ik_sxc
        integer:: nf,nl
        complex(8),allocatable:: work(:,:),vks(:,:),uk2w(:,:),vwann(:,:),&
     &                           sigm_t(:,:,:) 
        
        !! vks -- temporary array to store Sxc or Vxc in the KS representation
        !! uk2w - temporaty array to store the unitary transform from KS
        !         to Wannier representation  
    
        nf = nbmin_wf
        nl = nbmax_wf
        nbwf = nl - nf + 1 
        allocate(work(nlmorb,nbwf),   &
     &           vks(nf:nl,nf:nl),    &
     &           vwann(nf:nl,nf:nl),  &
     &           uk2w(nlmorb,nf:nl),  &
     &           sigm_t(nf:nl,nf:nl,0:nomeg) )
        hks_wann=0.d0
        do isp=1,nspin
          do ik=1,nkp
            call get_kvec(0,ik,itmp,irk) 
            if(isym_kbz.eq.0) then 
              ik_sxc = ik
              ik_pln = ik 
            else
              ik_sxc = irk 
              call get_kvec(1,irk,ik_pln,itmp) 
            endif 

            uk2w = pln(:,:,ik_pln,isp)

            do iom=1,nomeg 
              !! Sxc 
              vks(nf:nl,nf:nl)= sigm(nf:nl,nf:nl,0,ik_sxc,isp) & 
     &           + sigm(nf:nl,nf:nl,iom,ik_sxc,isp) 

              call sub_ks2wann(vks,sxc_wann(:,:,iom,ik,isp),uk2w, &
     &         work,nbwf,nlmorb,1)
            enddo 

            !! Vxc 
            call sub_ks2wann(vxcmn(nf:nl,nf:nl,ik_sxc,isp),& 
     &       vxc_wann(:,:,ik,isp),uk2w,work,nbwf,nlmorb,1) 

            !! H_ks
            vks = 0.d0 
            do ie = nf, nl
              vks(ie,ie) = bande(ie,irk,isp) + eferks
            enddo 
            call sub_ks2wann(vks,hks_wann(:,:,ik,isp),uk2w,work,&
     &       nbwf,nlmorb,1) 
            call sub_solve_eig(hks_wann(:,:,ik,isp),nlmorb)

            !! H_GW: obtain the effective GW Hamiltonian  
            if(iop_hgw.eq.0) then !! G0W0 
              vks = 0.d0 
              do ie = nf, nl
                vks(ie,ie) = eqp(ie,irk,isp) + eferks 
              enddo
              call sub_ks2wann(vks,hgw_wann(:,:,ik,isp),uk2w,work,&
     &         nbwf,nlmorb,1)

!              call calc_spectfunc(0,nf,nl,'G0W0') 

            else if (iop_hgw.eq.1) then
              do iom=0,nomeg
                sigm_t(:,:,iom) = sigm(nf:nl,nf:nl,iom,ik_sxc,isp)
              enddo 
              call scgw_herm_sxc(iop_sxc,sigm_t,bande(nf:nl,irk,isp), &
     &          nf,nl,omega,nomeg,vks)
              call sub_ks2wann(vks,vwann,uk2w,work,nbwf,nlmorb,1)
            
              hgw_wann(:,:,ik,isp) = hks_wann(:,:,ik,isp) &
     &          - vxc_wann(:,:,ik,isp) + vwann
            endif 

          enddo
        enddo
        deallocate(work,vks,sigm_t) 
        end subroutine 

!-----------------------------------------------------------------------
!  internal utility subroutine to transform a matrix in the KS basis   !
!  to the  Wannier basis                                               !
!-----------------------------------------------------------------------                            
        subroutine sub_ks2wann(mat_k,mat_w,uk2w,work,nks,nwf,nt) 
        implicit none
        integer:: nks,nwf,nt
        complex(8):: mat_k(nks,nks,nt),mat_w(nwf,nwf,nt),uk2w(nwf,nks)
        complex(8):: work(nwf,nks)

        integer:: i
        complex(8):: zone=1.0,czero=0.0  
        do i=1,nt
          call zgemm('n','n',nwf,nks,nks,zone,uk2w,nwf,mat_k(:,:,i),nks,&
     &             czero,work,nwf) 
          call zgemm('n','c',nwf,nwf,nks,zone,work,nwf,uk2w,nwf,czero,  & 
     &             mat_w(:,:,i),nwf)
        enddo   
        end subroutine

!-----------------------------------------------------------------------
!      internal subroutine to interpolate sc_wann to Matsubara freq.   ! 
!      by using some interpolation technique                           !
!-----------------------------------------------------------------------                            
        subroutine sub_intpl_mats
        integer:: isp,ik,iwf,jwf,iom 
        real(8):: w0 
        complex(8),allocatable:: sc1(:),sc2(:) 

        allocate(omega_mats(nomeg_mats),                    &
     &           sxc_wann_mats(nlmorb,nlmorb,nomeg_mats,nkp,nspin),&
     &           stat=ierr)
        call errmsg(ierr.ne.0,sname,"Fail to init sc_wann_mats")

        sxc_wann_mats = 0.d0
        beta_mats = beta_mats_eV*27.211
        w0 =  pi/beta_mats
        do iom=1,nomeg_mats
          omega_mats(iom) = w0*(2*iom-1)
        enddo

        allocate(sc1(nomeg),sc2(nomeg_mats))
        do isp=1,nspin
          do ik=1,nkp
            do jwf=1,nlmorb
              do iwf=1,nlmorb

                do iom=1,nomeg 
                  sc1(iom) = sxc_wann(iwf,jwf,iom,ik,isp)
                enddo 
                call freq_intpl_ac(iop_intpl_mats,sc1,omega,nomeg,sc2, & 
     &           omega_mats,nomeg_mats,0)
                do iom=1,nomeg_mats
                  sxc_wann_mats(iwf,jwf,iom,ik,isp) = sc2(iom)
                enddo 
              enddo !! iwf
            enddo ! jwf
          enddo ! ik
        enddo ! isp 
        end subroutine 

!
!       Using the diagonal elements of Sxcmn and Vxcmn matrices to calculate 
!       one-shot QP energies
!
        subroutine sub_calc_eqp_diag
        integer:: ie,irk,ik,isp,iom,irk_t,iik

        do isp=1,nspin 
          do irk=1,nirkp
            call get_kvec(1,irk,ik,irk_t)
            if(isym_kbz.eq.0) then
              iik = ik
            else
              iik = irk
            endif
            do ie=ibgw, nbgw
              sigx(ie,irk,isp) = sigm(ie,ie,0,iik,isp) 
              vxcnn(ie,irk,isp) = vxcmn(ie,ie,iik,isp) 
              do iom=1,nomeg
                sigc(iom,ie,irk,isp)= sigm(ie,ie,iom,iik,isp) 
              enddo 
            enddo
          enddo
        enddo 
        call calceqp(0,0,-1) 
        call io_eqp('w',iop_sxc,1,"G0W0")
        call io_eqp('w',iop_sxc,0,"G0W0")
        call bandanaly(ibgw,nbgw,nirkp,kirvecs,eqp,eferqp,nspin,"G0W0")
        end subroutine 

!
!       Using the full Sxcmn and Vxcmn matrices to calculate 
!       one-shot QP energies
!
        subroutine sub_calc_eqp_full
        integer:: ie,je,irk,ik,isp,iom,irk_t,iik
        integer:: nsize,lwork,rwsize
        complex(8),allocatable:: hgw(:,:)  !! effective Hamiltonian correspoding to GW 
        real(8),allocatable::rwork(:),ev(:)
        complex(8),allocatable::work(:),htmp(:,:)

        nsize = nbgw - ibgw + 1
        lwork=2*nsize
        rwsize=3*nsize
        allocate(hgw(ibgw:nbgw,ibgw:nbgw),work(lwork),rwork(rwsize),&
     &           ev(nsize))

        do isp=1,nspin
          do irk=1,nirkp
            call get_kvec(1,irk,ik,irk_t)
            if(isym_kbz.eq.0) then
              iik = ik
            else
              iik = irk
            endif
            call scgw_herm_sxc(iop_sxc,sigm(:,:,:,iik,isp),& 
     &       bande(ibgw:nbgw,irk,isp),ibgw,nbgw,omega,nomeg,hgw)
            hgw = hgw - vxcmn(:,:,iik,isp) 
            do ie=ibgw, nbgw
              hgw(ie,ie) = hgw(ie,ie) + bande(ie,irk,isp) 
            enddo 
            write(6,*) "Diagonalize H_GW matrix "
            call zheev('v','u',nsize,hgw,nsize,ev,work,lwork,rwork,ierr)
            call errmsg(ierr.ne.0,sname,'Fail to diag. H_gw by zheev')  
            eqp(:,irk,isp) = ev(:) 
          enddo
        enddo
        call calceqp(0,1,-1) 
        call io_eqp('w',iop_sxc,0,"QGW")
        call io_eqp('w',iop_sxc,2,"QGW")
        call bandanaly(ibgw,nbgw,nirkp,kirvecs,eqp,eferqp,nspin,"QGW")
        deallocate(hgw,work,rwork,ev)
        end subroutine 

        subroutine sub_solve_eig(hmat,n)
        integer,intent(in):: n
        complex(8),intent(in):: hmat(n,n) 
        integer:: i,ierr
        integer:: lwork,rwsize
        real(8):: err
        real(8),allocatable::rwork(:),ev(:)
        complex(8),allocatable::work(:),htmp(:,:)

        lwork=2*n
        rwsize=3*n
        allocate(htmp(n,n),work(lwork),rwork(rwsize),ev(n))
        htmp=hmat 
        write(6,*) "Diagonalize H matrix in the Wannier basis"
        call zheev('v','u',n,htmp,n,ev,work,lwork,rwork,ierr)
        call errmsg(ierr.ne.0,sname,'Fail to diag. Hmat by zheev')
        write(6,'(a4,2a12)') "n","En(Ry)","En(eV)"
        do i=1,n
          write(6,'(i4,2f12.6)') i+nbmin_wf-1, ev(i)*2, ev(i)*HeV 
        enddo 
        deallocate(htmp,work,rwork,ev) 
        end subroutine  

      end subroutine task_gw2wann
!EOC      
